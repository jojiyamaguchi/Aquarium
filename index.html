<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #4682B4);
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <iframe srcdoc="
        <html>
        <head>
            <style>
                body {
                    margin: 0;
                    overflow: hidden;
                    background: linear-gradient(to bottom, #87CEEB, #4682B4);
                }
                canvas {
                    display: block;
                }
            </style>
        </head>
        <body>
            <canvas id='myCanvas'></canvas>
            <script>
                const canvas = document.getElementById('myCanvas');
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const fishes = [];
                const numFishes = 50;

                for (let i = 0; i < numFishes; i++) {
                    const fish = {
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        angle: Math.random() * Math.PI * 2,
                        rotationSpeed: Math.random() * 0.02 - 0.01,
                        tailAngle: 0,
                        tailRotationSpeed: 0.025,
                        speed: 1,
                        isRed: Math.random() < 0.25,
                        separationDistance: 200,
                        cohesionDistance: 500,
                        maxSpeed: 2,
                        tailRotationDirection: Math.random() > 0.5 ? 1 : -1,
                        tailRotationLimit: 1,
                        followState: false,
                        leavingState: false
                    };
                    fishes.push(fish);
                }

                let isMouseDown = false;
                let mouseX = 0;
                let mouseY = 0;

                canvas.addEventListener('mousedown', (event) => {
                    isMouseDown = true;
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                });

                canvas.addEventListener('mouseup', () => {
                    isMouseDown = false;
                });

                function drawRipple(x, y) {
                    ctx.beginPath();
                    ctx.arc(x, y, 50, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
                    ctx.fill();
                    ctx.closePath();
                }

                function drawFish(x, y, angle, isRed, tailAngle) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle);

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(50, -15);
                    ctx.lineTo(100, 0);
                    ctx.lineTo(50, 15);
                    ctx.lineTo(0, 0);
                    ctx.fillStyle = isRed ? 'red' : 'black';
                    ctx.fill();
                    ctx.closePath();

                    ctx.save();
                    ctx.translate(0, 0);
                    ctx.rotate(tailAngle);

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-25, -7);
                    ctx.lineTo(-25, 7);
                    ctx.lineTo(0, 0);
                    ctx.fillStyle = isRed ? 'red' : 'black';
                    ctx.fill();
                    ctx.closePath();

                    ctx.restore();

                    ctx.restore();
                }

                function update() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    if (isMouseDown) {
                        fishes.forEach((fish) => {
                            let angleToMouse = Math.atan2(mouseY - fish.y, mouseX - fish.x);
                            fish.angle += (angleToMouse - fish.angle) * 0.01;
                        });
                        drawRipple(mouseX, mouseY);
                    }

                    fishes.forEach((fish, index) => {
                        let dx = Math.cos(fish.angle) * fish.speed;
                        let dy = Math.sin(fish.angle) * fish.speed;

                        let closeFishes = fishes.filter((otherFish, otherIndex) => {
                            if (index !== otherIndex) {
                                let distance = Math.sqrt((fish.x - otherFish.x) ** 2 + (fish.y - otherFish.y) ** 2);
                                return distance < fish.separationDistance;
                            }
                        });

                        if (closeFishes.length > 0) {
                            let avgAngle = closeFishes.reduce((acc, curr) => acc + curr.angle, 0) / closeFishes.length;
                            fish.angle += (avgAngle - fish.angle) * 0.01;

                            if (closeFishes.every((otherFish) => {
                                let distance = Math.sqrt((fish.x - otherFish.x) ** 2 + (fish.y - otherFish.y) ** 2);
                                return distance < fish.cohesionDistance;
                            })) {
                                let avgSpeed = closeFishes.reduce((acc, curr) => acc + curr.speed, 0) / closeFishes.length;
                                if (avgSpeed < fish.speed * fish.maxSpeed) {
                                    fish.speed = avgSpeed;
                                }
                                if (!fish.followState) {
                                    let nearestFish = closeFishes.reduce((nearest, current) => {
                                        let distanceToNearest = Math.sqrt((fish.x - nearest.x) ** 2 + (fish.y - nearest.y) ** 2);
                                        let distanceToCurrent = Math.sqrt((fish.x - current.x) ** 2 + (fish.y - current.y) ** 2);
                                        return distanceToCurrent < distanceToNearest ? current : nearest;
                                    });
                                    let angleToNearest = Math.atan2(nearestFish.y - fish.y, nearestFish.x - fish.x);
                                    let angleDiff = Math.abs(angleToNearest - fish.angle);
                                    if (angleDiff < Math.PI / 8) {
                                        fish.angle += (angleToNearest - fish.angle) * 0.01;
                                        fish.followState = true;
                                    }
                                }
                            } else {
                                if (!fish.followState) {
                                    fish.speed = fish.maxSpeed;
                                }
                                fish.followState = false;
                            }

                            let backFish = closeFishes.reduce((back, current) => {
                                let distanceToBack = Math.sqrt((fish.x - back.x) ** 2 + (fish.y - back.y) ** 2);
                                let distanceToCurrent = Math.sqrt((fish.x - current.x) ** 2 + (fish.y - current.y) ** 2);
                                return distanceToCurrent > distanceToBack ? current : back;
                            });
                            if (backFish.speed > 0.5) {
                                backFish.speed -= 0.1;
                            }
                        } else {
                            if (fish.speed > 1) {
                                fish.speed -= 0.1;
                            } else {
                                fish.speed += 0.1;
                            }
                        }

                        if (Math.random() < 0.01) {
                            fish.rotationSpeed = Math.random() * 0.02 - 0.01;
                        }

                        if (fish.x < 0 || fish.x > canvas.width || fish.y < 0 || fish.y > canvas.height) {
                            fish.angle = Math.atan2(canvas.height / 2 - fish.y, canvas.width / 2 - fish.x);
                            fish.speed = 0.5;
                        }

                        fish.x += Math.cos(fish.angle) * fish.speed;
                        fish.y += Math.sin(fish.angle) * fish.speed;

                        fish.tailAngle += fish.tailRotationSpeed * fish.tailRotationDirection;
                        if (fish.tailAngle >= fish.tailRotationLimit || fish.tailAngle <= -fish.tailRotationLimit) {
                            fish.tailRotationDirection *= -1;
                        }

                        if (!closeFishes.some((otherFish) => {
                            let distance = Math.sqrt((fish.x - otherFish.x) ** 2 + (fish.y - otherFish.y) ** 2);
                            return distance < fish.cohesionDistance;
                        }) && fish.speed < fish.maxSpeed) {
                            fish.speed += 0.1;
                        }

                        let targetAngle = Math.atan2(dy, dx);
                        let angleDiff = targetAngle - fish.angle;
                        if (angleDiff > Math.PI) {
                            angleDiff -= 2 * Math.PI;
                        } else if (angleDiff < -Math.PI) {
                            angleDiff += 2 * Math.PI;
                        }
                        fish.angle += angleDiff * 0.01;

                        drawFish(fish.x, fish.y, fish.angle, fish.isRed, fish.tailAngle);
                    });

                    setTimeout(update, 1000 / 60);
                }
                update();
            </script>
        </body>
        </html>
    " style="width: 100%; height: 100vh; border: none;"></iframe>
</body>
</html>
