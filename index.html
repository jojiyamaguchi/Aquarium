修正後のコードは以下の通りです。

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #4682B4);
        }
    </style>
</head>
<body>
    <canvas id="myCanvas"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const fishes = [];
        const numFishes = 50; // 魚の数を増やす

        for (let i = 0; i < numFishes; i++) {
            const fish = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                angle: Math.random() * Math.PI * 2,
                rotationSpeed: Math.random() * 0.02 - 0.01,
                tailAngle: 0, // FishTailの回転角を追加
                tailRotationSpeed:  0.025, // FishTailの回転速度を追加
                speed: 1,
                redVertex: Math.floor(Math.random() * 3),
                separationDistance: 5, // 他の魚との最小距離を5pxに設定
                cohesionDistance: 200, // 群れを作る距離を100pxに設定
                maxSpeed: 2, // 速度の最大倍率を1.1倍に設定
                tailRotationDirection: 1, // FishTailの回転方向を追加
                tailRotationLimit: 1 // FishTailの回転角の限界値を追加
            };
            fishes.push(fish);
        }

        let isMouseDown = false;
        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        function drawRipple(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 50, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(173, 216, 230, 0.5)';
            ctx.fill();
            ctx.closePath();
        }

        function drawFish(x, y, angle, redVertex, tailAngle) {
            ctx.save(); // Save the current transformation matrix

            // Translate to the center of the fish
            ctx.translate(x, y);

            // Rotate the fish based on the angle
            ctx.rotate(angle);

            // Fish body
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(50, -15);
            ctx.lineTo(100, 0);
            ctx.lineTo(50, 15);
            ctx.lineTo(0, 0);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.closePath();

            // Fish Tail
            ctx.save(); // Save the current transformation matrix for the tail
            ctx.translate(0, 0); // Translate to the tail base
            ctx.rotate(tailAngle); // Rotate the tail based on the tailAngle

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-25, -7);
            ctx.lineTo(-25, 7);
            ctx.lineTo(0, 0);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.closePath();

            ctx.restore(); // Restore the saved transformation matrix for the tail

            ctx.restore(); // Restore the saved transformation matrix
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (isMouseDown) {
                fishes.forEach((fish) => {
                    let angleToMouse = Math.atan2(mouseY - fish.y, mouseX - fish.x);
                    fish.angle += (angleToMouse - fish.angle) * 0.05; // ゆっくりとマウスの方向に向けて回転
                });
                drawRipple(mouseX, mouseY);
            }

            fishes.forEach((fish, index) => {
                let dx = Math.cos(fish.angle) * fish.speed;
                let dy = Math.sin(fish.angle) * fish.speed;

                let closeFishes = fishes.filter((otherFish, otherIndex) => {
                    if (index !== otherIndex) {
                        let distance = Math.sqrt((fish.x - otherFish.x) ** 2 + (fish.y - otherFish.y) ** 2);
                        return distance < fish.separationDistance;
                    }
                });

                if (closeFishes.length > 0) {
                    let avgAngle = closeFishes.reduce((acc, curr) => acc + curr.angle, 0) / closeFishes.length;
                    fish.angle += (avgAngle - fish.angle) * 0.01; // ゆっくりと合流するように変更

                    if (closeFishes.every((otherFish) => {
                        let distance = Math.sqrt((fish.x - otherFish.x) ** 2 + (fish.y - otherFish.y) ** 2);
                        return distance < fish.cohesionDistance;
                    })) {
                        let avgSpeed = closeFishes.reduce((acc, curr) => acc + curr.speed, 0) / closeFishes.length;
                        if (avgSpeed < fish.speed * fish.maxSpeed) {
                            fish.speed = avgSpeed;
                        }
                    } else {
                        fish.speed = 1; // 自分と同じ進行方向の相手に接近しようと加速している個体以外は、通常の移動速度まで減速
                    }
                }

                if (Math.random() < 0.01) {
                    fish.rotationSpeed = Math.random() * 0.02 - 0.01;
                }

                if (fish.x < 0 || fish.x > canvas.width) {
                    fish.angle = Math.atan2(canvas.height / 2 - fish.y, canvas.width / 2 - fish.x);
                    fish.speed = 0.5;
                }
                if (fish.y < 0 || fish.y > canvas.height) {
                    fish.angle = Math.atan2(canvas.height / 2 - fish.y, canvas.width / 2 - fish.x);
                    fish.speed = 0.5;
                }

                fish.x += Math.cos(fish.angle) * fish.speed;
                fish.y += Math.sin(fish.angle) * fish.speed;

                // FishTailの回転角を更新
                fish.tailAngle += fish.tailRotationSpeed * fish.tailRotationDirection;
                if (fish.tailAngle >= fish.tailRotationLimit || fish.tailAngle <= -fish.tailRotationLimit) {
                    fish.tailRotationDirection *= -1; // 回転方向を反転
                }

                drawFish(fish.x, fish.y, fish.angle, fish.redVertex, fish.tailAngle);
            });

            requestAnimationFrame(update);
        }

        update();
    </script>
</body>
</html>
```
